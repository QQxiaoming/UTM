diff --color -Naru ./audio/audio.c ./audio/audio.c
--- ./audio/audio.c	2022-04-23 02:42:13.000000000 +0800
+++ ./audio/audio.c	2022-07-21 16:06:46.322584034 +0800
@@ -1731,11 +1731,6 @@
         legacy_config = false;
         drvname = AudiodevDriver_str(dev->driver);
     } else if (!QTAILQ_EMPTY(&audio_states)) {
-        if (!legacy_config) {
-            dolog("Device %s: audiodev default parameter is deprecated, please "
-                  "specify audiodev=%s\n", name,
-                  QTAILQ_FIRST(&audio_states)->dev->id);
-        }
         return QTAILQ_FIRST(&audio_states);
     } else {
         /* legacy implicit initialization */
diff --color -Naru ./configs/devices/riscv32-softmmu/default.mak ./configs/devices/riscv32-softmmu/default.mak
--- ./configs/devices/riscv32-softmmu/default.mak	2022-04-23 02:42:13.000000000 +0800
+++ ./configs/devices/riscv32-softmmu/default.mak	2022-07-21 16:07:02.698815019 +0800
@@ -12,4 +12,5 @@
 CONFIG_SIFIVE_E=y
 CONFIG_SIFIVE_U=y
 CONFIG_RISCV_VIRT=y
+CONFIG_QUARD_STAR=y
 CONFIG_OPENTITAN=y
diff --color -Naru ./configs/devices/riscv64-softmmu/default.mak ./configs/devices/riscv64-softmmu/default.mak
--- ./configs/devices/riscv64-softmmu/default.mak	2022-04-23 02:42:13.000000000 +0800
+++ ./configs/devices/riscv64-softmmu/default.mak	2022-07-21 16:07:31.439228276 +0800
@@ -12,5 +12,6 @@
 CONFIG_SIFIVE_E=y
 CONFIG_SIFIVE_U=y
 CONFIG_RISCV_VIRT=y
+CONFIG_QUARD_STAR=y
 CONFIG_MICROCHIP_PFSOC=y
 CONFIG_SHAKTI_C=y
diff --color -Naru ./hw/adc/Kconfig ./hw/adc/Kconfig
--- ./hw/adc/Kconfig	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/adc/Kconfig	2022-07-21 16:07:58.059619589 +0800
@@ -3,3 +3,6 @@
 
 config MAX111X
     bool
+
+config ZYNQ_XADC
+    bool
diff --color -Naru ./hw/adc/meson.build ./hw/adc/meson.build
--- ./hw/adc/meson.build	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/adc/meson.build	2022-07-21 16:08:11.479819843 +0800
@@ -1,5 +1,5 @@
 softmmu_ss.add(when: 'CONFIG_STM32F2XX_ADC', if_true: files('stm32f2xx_adc.c'))
 softmmu_ss.add(when: 'CONFIG_ASPEED_SOC', if_true: files('aspeed_adc.c'))
 softmmu_ss.add(when: 'CONFIG_NPCM7XX', if_true: files('npcm7xx_adc.c'))
-softmmu_ss.add(when: 'CONFIG_ZYNQ', if_true: files('zynq-xadc.c'))
+softmmu_ss.add(when: 'CONFIG_ZYNQ_XADC', if_true: files('zynq-xadc.c'))
 softmmu_ss.add(when: 'CONFIG_MAX111X', if_true: files('max111x.c'))
diff --color -Naru ./hw/arm/Kconfig ./hw/arm/Kconfig
--- ./hw/arm/Kconfig	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/arm/Kconfig	2022-07-21 16:09:04.476629011 +0800
@@ -303,6 +303,7 @@
     select XILINX_AXI
     select XILINX_SPI
     select XILINX_SPIPS
+    select ZYNQ_XADC
     select ZYNQ_DEVCFG
 
 config ARM_V7M
diff --color -Naru ./hw/misc/Kconfig ./hw/misc/Kconfig
--- ./hw/misc/Kconfig	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/misc/Kconfig	2022-07-21 16:09:30.905042836 +0800
@@ -171,4 +171,7 @@
 config VIRT_CTRL
     bool
 
+config QUARD_STAR_SYSCON
+    bool
+
 source macio/Kconfig
diff --color -Naru ./hw/misc/meson.build ./hw/misc/meson.build
--- ./hw/misc/meson.build	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/misc/meson.build	2022-07-21 16:10:02.909552513 +0800
@@ -33,6 +33,7 @@
 softmmu_ss.add(when: 'CONFIG_SIFIVE_E_PRCI', if_true: files('sifive_e_prci.c'))
 softmmu_ss.add(when: 'CONFIG_SIFIVE_U_OTP', if_true: files('sifive_u_otp.c'))
 softmmu_ss.add(when: 'CONFIG_SIFIVE_U_PRCI', if_true: files('sifive_u_prci.c'))
+softmmu_ss.add(when: 'CONFIG_QUARD_STAR_SYSCON', if_true: files('quard_star_syscon.c'))
 
 subdir('macio')
 
diff --color -Naru ./hw/misc/quard_star_syscon.c ./hw/misc/quard_star_syscon.c
--- ./hw/misc/quard_star_syscon.c	1970-01-01 07:30:00.000000000 +0730
+++ ./hw/misc/quard_star_syscon.c	2022-07-21 16:11:08.678626992 +0800
@@ -0,0 +1,177 @@
+/*
+ * QEMU RISC-V Quard Star Board system control
+ *
+ * Copyright (c) 2021 qiao qiming
+ *
+ * system control memory mapped device used to exit simulation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "qapi/error.h"
+#include "qemu/log.h"
+#include "qemu/module.h"
+#include "hw/qdev-properties.h"
+#include "sysemu/runstate.h"
+#include "hw/hw.h"
+#include "hw/misc/quard_star_syscon.h"
+
+#define QUARD_STAR_SYSCON_VERSION (0x00010000)
+
+#define QUARD_STAR_SYSCON_PFLASH_BOOT (0x1<<0)
+#define QUARD_STAR_SYSCON_SPI_BOOT    (0x1<<1)
+#define QUARD_STAR_SYSCON_SD_BOOT     (0x1<<2)
+#define QUARD_STAR_SYSCON_UART_UPDATE (0x1<<16)
+
+enum {
+    FINISHER_FAIL = 0x3333,
+    FINISHER_PASS = 0x5555,
+    FINISHER_RESET = 0x7777
+};
+
+enum {
+    CONTROL_REG   = 0x0,
+    BOOT_REG      = 0x4,
+    USER_BOOT_REG = 0x8,
+    VERSION_REG   = 0xc
+};
+
+static uint64_t quard_star_syscon_bootreg = QUARD_STAR_SYSCON_PFLASH_BOOT | QUARD_STAR_SYSCON_UART_UPDATE;
+static uint64_t quard_star_syscon_userbootreg = 0;
+
+static uint64_t quard_star_syscon_read(void *opaque, hwaddr addr, unsigned int size)
+{
+    switch (addr)
+    {
+    case CONTROL_REG:
+        return 0;
+    case BOOT_REG:
+        return quard_star_syscon_bootreg;    
+    case USER_BOOT_REG:
+        return quard_star_syscon_userbootreg;    
+    case VERSION_REG:
+        return QUARD_STAR_SYSCON_VERSION;
+    default:
+        break;
+    }
+    qemu_log_mask(LOG_GUEST_ERROR, "%s: read: addr=0x%x\n", __func__, (int)addr);
+    return 0;
+}
+
+static void quard_star_syscon_write(void *opaque, hwaddr addr,
+           uint64_t val64, unsigned int size)
+{
+    if (addr == CONTROL_REG) {
+        int status = val64 & 0xffff;
+        int code = (val64 >> 16) & 0xffff;
+        switch (status) {
+        case FINISHER_FAIL:
+            exit(code);
+        case FINISHER_PASS:
+            exit(0);
+        case FINISHER_RESET:
+            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);
+            return;
+        default:
+            break;
+        }
+    } else if(addr == USER_BOOT_REG) {
+        quard_star_syscon_userbootreg = val64;
+    }
+    qemu_log_mask(LOG_GUEST_ERROR, "%s: write: addr=0x%x val=0x%016" PRIx64 "\n",
+                  __func__, (int)addr, val64);
+}
+
+static Property quard_star_syscon_properties[] = {
+    DEFINE_PROP_STRING("boot-cfg", QuardStarSysconState, boot_cfg),
+    DEFINE_PROP_BOOL("update-cfg", QuardStarSysconState, update_cfg, true),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static const MemoryRegionOps quard_star_syscon_ops = {
+    .read = quard_star_syscon_read,
+    .write = quard_star_syscon_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .valid = {
+        .min_access_size = 2,
+        .max_access_size = 4
+    }
+};
+
+static void quard_star_syscon_realize(DeviceState *dev, Error **errp)
+{
+    QuardStarSysconState *s = QUARD_STAR_SYSCON(dev);
+
+    if(s->boot_cfg){
+        if (!strcmp(s->boot_cfg, "pflash")) {
+            quard_star_syscon_bootreg = QUARD_STAR_SYSCON_PFLASH_BOOT;
+        } else if (!strcmp(s->boot_cfg, "spi")) {
+            quard_star_syscon_bootreg = QUARD_STAR_SYSCON_SPI_BOOT;
+        } else if (!strcmp(s->boot_cfg, "sd")) {
+            quard_star_syscon_bootreg = QUARD_STAR_SYSCON_SD_BOOT;
+        }
+    }
+    if(s->update_cfg) {
+        quard_star_syscon_bootreg |= QUARD_STAR_SYSCON_UART_UPDATE;
+    } else {
+        quard_star_syscon_bootreg &= ~QUARD_STAR_SYSCON_UART_UPDATE;
+    }
+}
+
+static void quard_star_syscon_init(Object *obj)
+{
+    QuardStarSysconState *s = QUARD_STAR_SYSCON(obj);
+
+    memory_region_init_io(&s->mmio, obj, &quard_star_syscon_ops, s,
+                          TYPE_QUARD_STAR_SYSCON, 0x1000);
+    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->mmio);
+}
+
+static void quard_star_syscon_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->realize = quard_star_syscon_realize;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    device_class_set_props(dc, quard_star_syscon_properties);
+}
+
+static const TypeInfo quard_star_syscon_info = {
+    .name          = TYPE_QUARD_STAR_SYSCON,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(QuardStarSysconState),
+    .instance_init = quard_star_syscon_init,
+    .class_init    = quard_star_syscon_class_init,
+};
+
+static void quard_star_syscon_register_types(void)
+{
+    type_register_static(&quard_star_syscon_info);
+}
+
+type_init(quard_star_syscon_register_types)
+
+
+/*
+ * Create Test device.
+ */
+DeviceState *quard_star_syscon_create(hwaddr addr)
+{
+    DeviceState *dev = qdev_new(TYPE_QUARD_STAR_SYSCON);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, addr);
+    return dev;
+}
+
diff --color -Naru ./hw/net/can/xlnx-zynqmp-can.c ./hw/net/can/xlnx-zynqmp-can.c
--- ./hw/net/can/xlnx-zynqmp-can.c	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/net/can/xlnx-zynqmp-can.c	2022-07-21 16:14:18.701902009 +0800
@@ -250,6 +250,16 @@
     FIELD(AFIR4, AIIDL, 1, 18)
     FIELD(AFIR4, AIRTR, 0, 1)
 
+#define XCAN_IDR_IDE_MASK		0x00080000U
+#define XCAN_IDR_ID1_MASK		0xFFE00000U
+#define XCAN_IDR_ID2_MASK		0x0007FFFEU
+#define XCAN_IDR_RTR_MASK		0x00000001U
+#define XCAN_IDR_SRR_MASK		0x00100000U
+#define XCAN_IDR_ID1_SHIFT		21
+#define XCAN_IDR_ID2_SHIFT		1
+#define CAN_SFF_ID_BITS		    11
+#define CAN_EFF_ID_BITS		    29
+
 static void can_update_irq(XlnxZynqMPCANState *s)
 {
     uint32_t irq;
@@ -385,20 +395,65 @@
     update_status_register_mode_bits(s);
 }
 
+static uint32_t id_xcan2can(uint32_t id)
+{
+    uint32_t ret_id = 0; 
+    /* Change Xilinx CAN ID format to socketCAN ID format */
+	if (id & XCAN_IDR_IDE_MASK) {
+		/* The received frame is an Extended format frame */
+		ret_id = (id & XCAN_IDR_ID1_MASK) >> 3;
+		ret_id |= (id & XCAN_IDR_ID2_MASK) >>
+				XCAN_IDR_ID2_SHIFT;
+		ret_id |= QEMU_CAN_EFF_FLAG;
+		if (id & XCAN_IDR_RTR_MASK)
+			ret_id |= QEMU_CAN_RTR_FLAG;
+	} else {
+		/* The received frame is a standard format frame */
+		ret_id = (id & XCAN_IDR_ID1_MASK) >>
+				XCAN_IDR_ID1_SHIFT;
+		if (id & XCAN_IDR_SRR_MASK)
+			ret_id |= QEMU_CAN_RTR_FLAG;
+	}
+    return ret_id;
+}
+
+static uint32_t id_can2xcan(uint32_t id)
+{
+    uint32_t ret_id = 0;
+    if (id & QEMU_CAN_EFF_FLAG) {
+        /* Extended CAN ID format */
+        ret_id = ((id & QEMU_CAN_EFF_MASK) << XCAN_IDR_ID2_SHIFT) &
+            XCAN_IDR_ID2_MASK;
+        ret_id |= (((id & QEMU_CAN_EFF_MASK) >>
+            (CAN_EFF_ID_BITS - CAN_SFF_ID_BITS)) <<
+            XCAN_IDR_ID1_SHIFT) & XCAN_IDR_ID1_MASK;
+        ret_id |= XCAN_IDR_IDE_MASK | XCAN_IDR_SRR_MASK;
+        if (id & QEMU_CAN_RTR_FLAG)
+            ret_id |= XCAN_IDR_RTR_MASK;
+    } else {
+        /* Standard CAN ID format */
+        ret_id = ((id & QEMU_CAN_SFF_MASK) << XCAN_IDR_ID1_SHIFT) &
+            XCAN_IDR_ID1_MASK;
+        if (id & QEMU_CAN_RTR_FLAG)
+            ret_id |= XCAN_IDR_SRR_MASK;
+    }
+    return ret_id;
+}
+
 static void generate_frame(qemu_can_frame *frame, uint32_t *data)
 {
-    frame->can_id = data[0];
+    frame->can_id = id_xcan2can(data[0]);
     frame->can_dlc = FIELD_EX32(data[1], TXFIFO_DLC, DLC);
 
-    frame->data[0] = FIELD_EX32(data[2], TXFIFO_DATA1, DB3);
-    frame->data[1] = FIELD_EX32(data[2], TXFIFO_DATA1, DB2);
-    frame->data[2] = FIELD_EX32(data[2], TXFIFO_DATA1, DB1);
-    frame->data[3] = FIELD_EX32(data[2], TXFIFO_DATA1, DB0);
-
-    frame->data[4] = FIELD_EX32(data[3], TXFIFO_DATA2, DB7);
-    frame->data[5] = FIELD_EX32(data[3], TXFIFO_DATA2, DB6);
-    frame->data[6] = FIELD_EX32(data[3], TXFIFO_DATA2, DB5);
-    frame->data[7] = FIELD_EX32(data[3], TXFIFO_DATA2, DB4);
+    frame->data[0] = FIELD_EX32(data[2], TXFIFO_DATA1, DB0);
+    frame->data[1] = FIELD_EX32(data[2], TXFIFO_DATA1, DB1);
+    frame->data[2] = FIELD_EX32(data[2], TXFIFO_DATA1, DB2);
+    frame->data[3] = FIELD_EX32(data[2], TXFIFO_DATA1, DB3);
+
+    frame->data[4] = FIELD_EX32(data[3], TXFIFO_DATA2, DB4);
+    frame->data[5] = FIELD_EX32(data[3], TXFIFO_DATA2, DB5);
+    frame->data[6] = FIELD_EX32(data[3], TXFIFO_DATA2, DB6);
+    frame->data[7] = FIELD_EX32(data[3], TXFIFO_DATA2, DB7);
 }
 
 static bool tx_ready_check(XlnxZynqMPCANState *s)
@@ -686,7 +741,7 @@
         } else {
             timestamp = CAN_TIMER_MAX - ptimer_get_count(s->can_timer);
 
-            fifo32_push(&s->rx_fifo, frame->can_id);
+            fifo32_push(&s->rx_fifo, id_can2xcan(frame->can_id));
 
             fifo32_push(&s->rx_fifo, deposit32(0, R_RXFIFO_DLC_DLC_SHIFT,
                                                R_RXFIFO_DLC_DLC_LENGTH,
@@ -696,30 +751,30 @@
                                                timestamp));
 
             /* First 32 bit of the data. */
-            fifo32_push(&s->rx_fifo, deposit32(0, R_TXFIFO_DATA1_DB3_SHIFT,
-                                               R_TXFIFO_DATA1_DB3_LENGTH,
+            fifo32_push(&s->rx_fifo, deposit32(0, R_TXFIFO_DATA1_DB0_SHIFT,
+                                               R_TXFIFO_DATA1_DB0_LENGTH,
                                                frame->data[0]) |
-                                     deposit32(0, R_TXFIFO_DATA1_DB2_SHIFT,
-                                               R_TXFIFO_DATA1_DB2_LENGTH,
-                                               frame->data[1]) |
                                      deposit32(0, R_TXFIFO_DATA1_DB1_SHIFT,
                                                R_TXFIFO_DATA1_DB1_LENGTH,
+                                               frame->data[1]) |
+                                     deposit32(0, R_TXFIFO_DATA1_DB2_SHIFT,
+                                               R_TXFIFO_DATA1_DB2_LENGTH,
                                                frame->data[2]) |
-                                     deposit32(0, R_TXFIFO_DATA1_DB0_SHIFT,
-                                               R_TXFIFO_DATA1_DB0_LENGTH,
+                                     deposit32(0, R_TXFIFO_DATA1_DB3_SHIFT,
+                                               R_TXFIFO_DATA1_DB3_LENGTH,
                                                frame->data[3]));
             /* Last 32 bit of the data. */
-            fifo32_push(&s->rx_fifo, deposit32(0, R_TXFIFO_DATA2_DB7_SHIFT,
-                                               R_TXFIFO_DATA2_DB7_LENGTH,
+            fifo32_push(&s->rx_fifo, deposit32(0, R_TXFIFO_DATA2_DB4_SHIFT,
+                                               R_TXFIFO_DATA2_DB4_LENGTH,
                                                frame->data[4]) |
-                                     deposit32(0, R_TXFIFO_DATA2_DB6_SHIFT,
-                                               R_TXFIFO_DATA2_DB6_LENGTH,
-                                               frame->data[5]) |
                                      deposit32(0, R_TXFIFO_DATA2_DB5_SHIFT,
                                                R_TXFIFO_DATA2_DB5_LENGTH,
+                                               frame->data[5]) |
+                                     deposit32(0, R_TXFIFO_DATA2_DB6_SHIFT,
+                                               R_TXFIFO_DATA2_DB6_LENGTH,
                                                frame->data[6]) |
-                                     deposit32(0, R_TXFIFO_DATA2_DB4_SHIFT,
-                                               R_TXFIFO_DATA2_DB4_LENGTH,
+                                     deposit32(0, R_TXFIFO_DATA2_DB7_SHIFT,
+                                               R_TXFIFO_DATA2_DB7_LENGTH,
                                                frame->data[7]));
 
             ARRAY_FIELD_DP32(s->regs, INTERRUPT_STATUS_REGISTER, RXOK, 1);
diff --color -Naru ./hw/riscv/Kconfig ./hw/riscv/Kconfig
--- ./hw/riscv/Kconfig	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/riscv/Kconfig	2022-07-21 16:15:19.915000906 +0800
@@ -49,6 +49,40 @@
     select VIRTIO_MMIO
     select FW_CFG_DMA
 
+config QUARD_STAR
+    bool
+    select QUARD_STAR_SYSCON
+    select GOLDFISH_RTC
+    select MSI_NONBROKEN
+    select PFLASH_CFI01
+    select SERIAL
+    select RISCV_ACLINT
+    select RISCV_APLIC
+    select RISCV_IMSIC
+    select SIFIVE_PLIC
+    select SIFIVE_GPIO
+    select SIFIVE_PDMA
+    select VIRTIO_MMIO
+    select FW_CFG_DMA
+    select I2C
+    select IMX_I2C
+    select AT24C
+    select SSI
+    select SIFIVE_SPI
+    select USB_DWC3
+    select USB
+    select ONENAND
+    select CADENCE
+    select CADENCE_SDHCI
+    select MARVELL_88W8618
+    select WM8750
+    select CAN_BUS
+    select WDT_IMX2
+    select ZYNQ_XADC
+    select XLNX_ZYNQMP
+    select SIFIVE_PWM
+    select PL110
+
 config SIFIVE_E
     bool
     select MSI_NONBROKEN
diff --color -Naru ./hw/riscv/meson.build ./hw/riscv/meson.build
--- ./hw/riscv/meson.build	2022-04-23 02:42:13.000000000 +0800
+++ ./hw/riscv/meson.build	2022-07-21 16:15:41.243387979 +0800
@@ -4,6 +4,7 @@
 riscv_ss.add(files('riscv_hart.c'))
 riscv_ss.add(when: 'CONFIG_OPENTITAN', if_true: files('opentitan.c'))
 riscv_ss.add(when: 'CONFIG_RISCV_VIRT', if_true: files('virt.c'))
+riscv_ss.add(when: 'CONFIG_QUARD_STAR', if_true: files('quard_star.c'))
 riscv_ss.add(when: 'CONFIG_SHAKTI_C', if_true: files('shakti_c.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_E', if_true: files('sifive_e.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_U', if_true: files('sifive_u.c'))
diff --color -Naru ./hw/riscv/quard_star.c ./hw/riscv/quard_star.c
--- ./hw/riscv/quard_star.c	1970-01-01 07:30:00.000000000 +0730
+++ ./hw/riscv/quard_star.c	2022-07-21 16:16:04.063804365 +0800
@@ -0,0 +1,697 @@
+/*
+ * QEMU RISC-V Quard Star Board
+ *
+ * Copyright (c) 2021 qiao qiming
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "hw/sysbus.h"
+#include "hw/qdev-properties.h"
+#include "hw/char/serial.h"
+#include "target/riscv/cpu.h"
+#include "hw/riscv/riscv_hart.h"
+#include "hw/riscv/quard_star.h"
+#include "hw/riscv/boot.h"
+#include "hw/riscv/numa.h"
+#include "hw/intc/riscv_aclint.h"
+#include "hw/intc/riscv_aplic.h"
+#include "hw/intc/riscv_imsic.h"
+#include "hw/intc/sifive_plic.h"
+#include "hw/misc/quard_star_syscon.h"
+#include "hw/audio/wm8750.h"
+#include "chardev/char.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/sysemu.h"
+#include "net/net.h"
+#include "hw/misc/unimp.h"
+
+#define GEM_REVISION        0x10070109
+
+static const MemMapEntry quard_star_memmap[] = {
+    [QUARD_STAR_MROM]        = { 0x00000000,   0x20000 },
+    [QUARD_STAR_SRAM]        = { 0x00020000,   0xe0000 },
+    
+    [QUARD_STAR_SYSCTL]      = { 0x00100000,    0x1000 },
+    [QUARD_STAR_CLINT]       = { 0x02000000,   0x10000 },
+    [QUARD_STAR_PLIC]        = { 0x0c000000, 0x4000000 },
+
+    [QUARD_STAR_UART0]       = { 0x10000000,    0x1000 },
+    [QUARD_STAR_UART1]       = { 0x10001000,    0x1000 },
+    [QUARD_STAR_UART2]       = { 0x10002000,    0x1000 },
+    [QUARD_STAR_RTC]         = { 0x10003000,    0x1000 },
+    [QUARD_STAR_I2C0]        = { 0x10004000,    0x1000 },
+    [QUARD_STAR_I2C1]        = { 0x10005000,    0x1000 },
+    [QUARD_STAR_I2C2]        = { 0x10006000,    0x1000 },
+    [QUARD_STAR_SPI0]        = { 0x10007000,    0x1000 },
+    [QUARD_STAR_SPI1]        = { 0x10008000,    0x1000 },
+    [QUARD_STAR_GPIO]        = { 0x10009000,    0x1000 },
+    [QUARD_STAR_SDIO]        = { 0x1000a000,    0x1000 },
+    [QUARD_STAR_I2S]         = { 0x1000b000,    0x1000 },
+    [QUARD_STAR_CAN]         = { 0x1000c000,    0x1000 },
+    [QUARD_STAR_PWM]         = { 0x1000d000,    0x1000 },
+    [QUARD_STAR_ADC]         = { 0x1000e000,    0x1000 },
+    [QUARD_STAR_TIMER]       = { 0x1000f000,    0x1000 },
+    [QUARD_STAR_ETH]         = { 0x10010000,    0x3000 },
+    [QUARD_STAR_LCDC]        = { 0x10013000,    0x1000 },
+    [QUARD_STAR_WDT]         = { 0x10014000,    0x1000 },
+    
+    [QUARD_STAR_VIRTIO0]     = { 0x10100000,    0x1000 },
+    [QUARD_STAR_VIRTIO1]     = { 0x10101000,    0x1000 },
+    [QUARD_STAR_VIRTIO2]     = { 0x10102000,    0x1000 },
+    [QUARD_STAR_VIRTIO3]     = { 0x10103000,    0x1000 },
+    [QUARD_STAR_VIRTIO4]     = { 0x10104000,    0x1000 },
+    [QUARD_STAR_VIRTIO5]     = { 0x10105000,    0x1000 },
+    [QUARD_STAR_VIRTIO6]     = { 0x10106000,    0x1000 },
+    [QUARD_STAR_VIRTIO7]     = { 0x10107000,    0x1000 },
+    [QUARD_STAR_FW_CFG]      = { 0x10108000,      0x18 },
+    
+    [QUARD_STAR_USB]         = { 0x11000000,   0x10000 },
+    [QUARD_STAR_NAND]        = { 0x11010000,   0x20000 },
+    [QUARD_STAR_DMA]         = { 0x12000000,  0x100000 },
+    
+    [QUARD_STAR_FLASH]       = { 0x20000000, 0x2000000 },
+    [QUARD_STAR_DRAM]        = { 0x80000000,       0x0 },
+};
+
+static void quard_star_setup_rom_reset_vec(MachineState *machine, 
+                                RISCVHartArrayState *harts, hwaddr start_addr,
+                                hwaddr rom_base, hwaddr rom_size,
+                                uint64_t kernel_entry, uint32_t fdt_load_addr)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    uint32_t start_addr_hi32 = 0x00000000;
+
+    if (!riscv_is_32bit(harts)) {
+        start_addr_hi32 = start_addr >> 32;
+    }
+    /* reset vector */
+    uint32_t reset_vec[10] = {
+        0x00000297,                  /* 1:  auipc  t0, %pcrel_hi(fw_dyn) */
+        0x02828613,                  /*     addi   a2, t0, %pcrel_lo(1b) */
+        0xf1402573,                  /*     csrr   a0, mhartid  */
+        0,
+        0,
+        0x00028067,                  /*     jr     t0 */
+        start_addr,                  /* start: .dword */
+        start_addr_hi32,
+        fdt_load_addr,               /* fdt_laddr: .dword */
+        0x00000000,
+                                     /* fw_dyn: */
+    };
+    if (riscv_is_32bit(harts)) {
+        reset_vec[3] = 0x0202a583;   /*     lw     a1, 32(t0) */
+        reset_vec[4] = 0x0182a283;   /*     lw     t0, 24(t0) */
+    } else {
+        reset_vec[3] = 0x0202b583;   /*     ld     a1, 32(t0) */
+        reset_vec[4] = 0x0182b283;   /*     ld     t0, 24(t0) */
+    }
+
+    /* copy in the reset vector in little_endian byte order */
+    for (int i = 0; i < ARRAY_SIZE(reset_vec); i++) {
+        reset_vec[i] = cpu_to_le32(reset_vec[i]);
+    }
+
+    
+    if(s->mask_rom_path){
+        int image_size = load_image_targphys_as(s->mask_rom_path, rom_base,
+                                            rom_size, &address_space_memory);
+        if (image_size < 0) {
+            error_report("Could not load mrom '%s'", s->mask_rom_path);
+            exit(1);
+        }
+    } else {
+        rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+                          rom_base, &address_space_memory);
+    }
+}
+
+static void quard_star_cpu_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(machine), "c-cluster",
+                                    &s->c_cluster, TYPE_CPU_CLUSTER);
+    qdev_prop_set_uint32(DEVICE(&s->c_cluster), "cluster-id", 0);
+    object_initialize_child(OBJECT(&s->c_cluster), "c-cpus",
+                                &s->c_cpus, TYPE_RISCV_HART_ARRAY);
+    object_property_set_str(OBJECT(&s->c_cpus), "cpu-type",
+                            machine->cpu_type, &error_abort);
+    object_property_set_int(OBJECT(&s->c_cpus), "hartid-base",
+                            0, &error_abort);
+    object_property_set_int(OBJECT(&s->c_cpus), "num-harts",
+                            QUARD_STAR_COMPUTE_CPU_COUNT, &error_abort);
+    object_property_set_int(OBJECT(&s->c_cpus), "resetvec", 
+                            quard_star_memmap[QUARD_STAR_MROM].base, 
+                            &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&s->c_cpus), &error_abort);
+    qdev_realize(DEVICE(&s->c_cluster), NULL, &error_abort);
+
+    object_initialize_child(OBJECT(machine), "r-cluster", 
+                                    &s->r_cluster, TYPE_CPU_CLUSTER);
+    qdev_prop_set_uint32(DEVICE(&s->r_cluster), "cluster-id", 1);
+    object_initialize_child(OBJECT(&s->r_cluster), "r-cpus", 
+                            &s->r_cpus, TYPE_RISCV_HART_ARRAY);
+    object_property_set_str(OBJECT(&s->r_cpus), "cpu-type",
+                            machine->cpu_type, &error_abort);
+    object_property_set_int(OBJECT(&s->r_cpus), "hartid-base",
+                            7, &error_abort);
+    object_property_set_int(OBJECT(&s->r_cpus), "num-harts",
+                            QUARD_STAR_MANAGEMENT_CPU_COUNT, &error_abort);
+    object_property_set_int(OBJECT(&s->r_cpus), "resetvec", 
+                            quard_star_memmap[QUARD_STAR_MROM].base, 
+                            &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&s->r_cpus), &error_abort);
+    qdev_realize(DEVICE(&s->r_cluster), NULL, &error_abort);
+}
+
+static void quard_star_interrupt_controller_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    char *plic_hart_config;
+
+    riscv_aclint_swi_create(
+        quard_star_memmap[QUARD_STAR_CLINT].base,
+        0, machine->smp.cpus, false);
+    riscv_aclint_mtimer_create(quard_star_memmap[QUARD_STAR_CLINT].base + RISCV_ACLINT_SWI_SIZE,
+        RISCV_ACLINT_DEFAULT_MTIMER_SIZE, 0, machine->smp.cpus,
+        RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,
+        RISCV_ACLINT_DEFAULT_TIMEBASE_FREQ, true);
+
+    plic_hart_config = riscv_plic_hart_config_string(machine->smp.cpus);
+    s->plic = sifive_plic_create(
+        quard_star_memmap[QUARD_STAR_PLIC].base,
+        plic_hart_config,  machine->smp.cpus, 0,
+        QUARD_STAR_PLIC_NUM_SOURCES,
+        QUARD_STAR_PLIC_NUM_PRIORITIES,
+        QUARD_STAR_PLIC_PRIORITY_BASE,
+        QUARD_STAR_PLIC_PENDING_BASE,
+        QUARD_STAR_PLIC_ENABLE_BASE,
+        QUARD_STAR_PLIC_ENABLE_STRIDE,
+        QUARD_STAR_PLIC_CONTEXT_BASE,
+        QUARD_STAR_PLIC_CONTEXT_STRIDE,
+        quard_star_memmap[QUARD_STAR_PLIC].size);
+    g_free(plic_hart_config);
+}
+
+static void quard_star_memory_create(MachineState *machine)
+{
+    MemoryRegion *system_memory = get_system_memory();
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    MemoryRegion *main_mem = g_new(MemoryRegion, 1);
+    MemoryRegion *sram_mem = g_new(MemoryRegion, 1);
+    MemoryRegion *mask_rom = g_new(MemoryRegion, 1);
+
+    memory_region_init_ram(main_mem, NULL, "riscv_quard_star_board.dram",
+                           machine->ram_size, &error_fatal);
+    memory_region_add_subregion(system_memory, 
+                                quard_star_memmap[QUARD_STAR_DRAM].base, main_mem);
+
+    memory_region_init_ram(sram_mem, NULL, "riscv_quard_star_board.sram",
+                           quard_star_memmap[QUARD_STAR_SRAM].size, &error_fatal);
+    memory_region_add_subregion(system_memory, 
+                                quard_star_memmap[QUARD_STAR_SRAM].base, sram_mem);
+
+    memory_region_init_rom(mask_rom, NULL, "riscv_quard_star_board.mrom",
+                           quard_star_memmap[QUARD_STAR_MROM].size, &error_fatal);
+    memory_region_add_subregion(system_memory, 
+                                quard_star_memmap[QUARD_STAR_MROM].base, mask_rom);
+
+    quard_star_setup_rom_reset_vec(machine, &s->r_cpus, 
+                              quard_star_memmap[QUARD_STAR_FLASH].base,
+                              quard_star_memmap[QUARD_STAR_MROM].base,
+                              quard_star_memmap[QUARD_STAR_MROM].size,
+                              0x0, 0x0);
+}
+
+static void quard_star_serial_create(MachineState *machine)
+{    
+    MemoryRegion *system_memory = get_system_memory();
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART0].base,
+        0, qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_UART0_IRQ), 399193,
+        serial_hd(0), DEVICE_LITTLE_ENDIAN);
+    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART1].base,
+        0, qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_UART1_IRQ), 399193,
+        serial_hd(1), DEVICE_LITTLE_ENDIAN);
+    serial_mm_init(system_memory, quard_star_memmap[QUARD_STAR_UART2].base,
+        0, qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_UART2_IRQ), 399193,
+        serial_hd(2), DEVICE_LITTLE_ENDIAN);
+}
+
+static void quard_star_system_control_create(MachineState *machine)
+{    
+    quard_star_syscon_create(quard_star_memmap[QUARD_STAR_SYSCTL].base);
+}
+
+static void quard_star_rtc_create(MachineState *machine)
+{    
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    sysbus_create_simple("goldfish_rtc", quard_star_memmap[QUARD_STAR_RTC].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_RTC_IRQ));
+}
+
+static void quard_star_flash_create(MachineState *machine)
+{ 
+    MemoryRegion *system_memory = get_system_memory();
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    uint64_t flash_sector_size = 256 * KiB;
+    DeviceState *dev = qdev_new(TYPE_PFLASH_CFI01);
+
+    qdev_prop_set_uint64(dev, "sector-length", flash_sector_size);
+    qdev_prop_set_uint8(dev, "width", 4);
+    qdev_prop_set_uint8(dev, "device-width", 2);
+    qdev_prop_set_bit(dev, "big-endian", false);
+    qdev_prop_set_uint16(dev, "id0", 0x89);
+    qdev_prop_set_uint16(dev, "id1", 0x18);
+    qdev_prop_set_uint16(dev, "id2", 0x00);
+    qdev_prop_set_uint16(dev, "id3", 0x00);
+    qdev_prop_set_string(dev, "name", "quard-star.flash0");
+    object_property_add_child(OBJECT(s), "quard-star.flash0", OBJECT(dev));
+    object_property_add_alias(OBJECT(s), "pflash0",
+                              OBJECT(dev), "drive");
+    s->flash = PFLASH_CFI01(dev);
+    pflash_cfi01_legacy_drive(s->flash, drive_get(IF_PFLASH, 0, 0));
+
+    assert(QEMU_IS_ALIGNED(quard_star_memmap[QUARD_STAR_FLASH].size, 
+                                flash_sector_size));
+    assert(quard_star_memmap[QUARD_STAR_FLASH].size/flash_sector_size <= UINT32_MAX);
+    qdev_prop_set_uint32(dev, "num-blocks", 
+                    quard_star_memmap[QUARD_STAR_FLASH].size / flash_sector_size);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+
+    memory_region_add_subregion(system_memory, 
+                            quard_star_memmap[QUARD_STAR_FLASH].base,
+                            sysbus_mmio_get_region(SYS_BUS_DEVICE(dev), 0));
+}
+
+static void quard_star_i2c_create(MachineState *machine)
+{ 
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(machine), "i2c0", &s->i2c[0], TYPE_IMX_I2C);
+    sysbus_realize(SYS_BUS_DEVICE(&s->i2c[0]), &error_abort);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->i2c[0]), 0, 
+                        quard_star_memmap[QUARD_STAR_I2C0].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->i2c[0]), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_I2C0_IRQ));
+
+    object_initialize_child(OBJECT(machine), "i2c1", &s->i2c[1], TYPE_IMX_I2C);
+    sysbus_realize(SYS_BUS_DEVICE(&s->i2c[1]), &error_abort);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->i2c[1]), 0, 
+                        quard_star_memmap[QUARD_STAR_I2C1].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->i2c[1]), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_I2C1_IRQ));
+
+    object_initialize_child(OBJECT(machine), "i2c2", &s->i2c[2], TYPE_IMX_I2C);
+    sysbus_realize(SYS_BUS_DEVICE(&s->i2c[2]), &error_abort);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->i2c[2]), 0, 
+                        quard_star_memmap[QUARD_STAR_I2C2].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->i2c[2]), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_I2C2_IRQ));
+
+    s->at24c_dev = i2c_slave_new("at24c-eeprom", 0x50);
+    DeviceState *dev = DEVICE(s->at24c_dev);
+    qdev_prop_set_uint32(dev, "rom-size", 8*1024);
+    i2c_slave_realize_and_unref(s->at24c_dev, s->i2c[0].bus, &error_abort);
+
+    s->wm8750_dev = i2c_slave_new(TYPE_WM8750, 0x1a);
+    i2c_slave_realize_and_unref(s->wm8750_dev, s->i2c[1].bus, &error_abort);
+}
+
+static void quard_star_spi_create(MachineState *machine)
+{ 
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(machine), "spi0", &s->spi[0],
+                                TYPE_SIFIVE_SPI);
+    sysbus_realize(SYS_BUS_DEVICE(&s->spi[0]), &error_abort);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->spi[0]), 0, 
+                            quard_star_memmap[QUARD_STAR_SPI0].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->spi[0]), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_SPI0_IRQ));
+
+    object_initialize_child(OBJECT(machine), "spi1", &s->spi[1],
+                                TYPE_SIFIVE_SPI);
+    sysbus_realize(SYS_BUS_DEVICE(&s->spi[1]), &error_abort);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->spi[1]), 0, 
+                            quard_star_memmap[QUARD_STAR_SPI1].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->spi[1]), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_SPI1_IRQ));
+                    
+    DeviceState *flash_dev = qdev_new("is25wp256");
+    DriveInfo *dinfo = drive_get(IF_MTD,0,0);
+    if (dinfo) {
+        qdev_prop_set_drive_err(flash_dev, "drive",
+                                blk_by_legacy_dinfo(dinfo),
+                                &error_fatal);
+    }
+    qdev_realize_and_unref(flash_dev, BUS(s->spi[0].spi), &error_fatal);
+    qemu_irq flash_cs = qdev_get_gpio_in_named(flash_dev, SSI_GPIO_CS, 0);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->spi[0]), 1, flash_cs);
+}
+
+static void quard_star_usb_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(s), "dwc3", &s->usb,
+                            TYPE_USB_DWC3);
+    qdev_prop_set_uint32(DEVICE(&s->usb), "intrs", 1);
+    qdev_prop_set_uint32(DEVICE(&s->usb), "slots", 2);
+
+    sysbus_realize(SYS_BUS_DEVICE(&s->usb), &error_fatal);
+
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->usb), 0, 
+                            quard_star_memmap[QUARD_STAR_USB].base);
+    qdev_pass_gpios(DEVICE(&s->usb.sysbus_xhci), DEVICE(&s->usb), SYSBUS_DEVICE_GPIO_IRQ);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->usb), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_USB_IRQ));
+}
+
+static void quard_star_gpio_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    int i;
+
+    object_initialize_child(OBJECT(s), "gpio", &s->gpio, TYPE_SIFIVE_GPIO);
+    
+    qdev_prop_set_uint32(DEVICE(&s->gpio), "ngpio", 16);
+    sysbus_realize(SYS_BUS_DEVICE(&s->gpio), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpio), 0,
+                            quard_star_memmap[QUARD_STAR_GPIO].base);
+    for (i = 0; i < 16; i++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(&s->gpio), i,
+            qdev_get_gpio_in(DEVICE(s->plic),QUARD_STAR_GPIO_IRQ + i));
+    }
+}
+
+static void quard_star_dma_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    int i;
+    
+    object_initialize_child(OBJECT(s), "pdma", &s->dma, TYPE_SIFIVE_PDMA);
+
+    sysbus_realize(SYS_BUS_DEVICE(&s->dma), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->dma), 0, 
+                            quard_star_memmap[QUARD_STAR_DMA].base);
+    for (i = 0; i < SIFIVE_PDMA_IRQS; i++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(&s->dma), i,
+            qdev_get_gpio_in(DEVICE(s->plic),QUARD_STAR_DMA_IRQ + i));
+    }
+}
+
+static void quard_star_sdio_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    DriveInfo *dinfo = drive_get(IF_SD,0,0);
+
+    object_initialize_child(OBJECT(s), "sdhost", &s->sdhost, TYPE_CADENCE_SDHCI);
+    
+    sysbus_realize(SYS_BUS_DEVICE(&s->sdhost), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->sdhost), 0, 
+                            quard_star_memmap[QUARD_STAR_SDIO].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->sdhost), 0,
+                    qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_SDIO_IRQ));
+
+    if (dinfo) {
+        CadenceSDHCIState *sdhci = &(s->sdhost);
+        DeviceState *card = qdev_new(TYPE_SD_CARD);
+
+        qdev_prop_set_drive_err(card, "drive", blk_by_legacy_dinfo(dinfo),
+                                &error_fatal);
+        qdev_realize_and_unref(card, sdhci->bus, &error_fatal);
+    }
+}
+
+static void quard_star_i2s_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    
+    s->i2s = qdev_new(TYPE_MV88W8618_AUDIO);
+    object_property_set_link(OBJECT(s->i2s), "wm8750", OBJECT(s->wm8750_dev),
+                             NULL);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->i2s), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->i2s), 0, quard_star_memmap[QUARD_STAR_I2S].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(s->i2s), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_I2S_IRQ));
+}
+
+static void quard_star_nand_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+    DriveInfo *dinfo;
+
+    s->nand = qdev_new("onenand");
+    qdev_prop_set_uint16(s->nand, "manufacturer_id", NAND_MFR_SAMSUNG);
+    /* Either 0x40 or 0x48 are OK for the device ID */
+    qdev_prop_set_uint16(s->nand, "device_id", 0x48);
+    qdev_prop_set_uint16(s->nand, "version_id", 0);
+    qdev_prop_set_int32(s->nand, "shift", 1);
+    dinfo = drive_get(IF_MTD, 1, 0);
+    if (dinfo) {
+        qdev_prop_set_drive_err(s->nand, "drive", blk_by_legacy_dinfo(dinfo),
+                                &error_fatal);
+    }
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->nand), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->nand), 0, quard_star_memmap[QUARD_STAR_NAND].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_NAND_IRQ));
+}
+
+static void quard_star_can_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(s), "can", &s->can, TYPE_XLNX_ZYNQMP_CAN);
+
+    object_property_set_int(OBJECT(&s->can), "ext_clk_freq",
+                            (24*1000*1000), &error_abort);
+    object_property_set_link(OBJECT(&s->can), "canbus",
+                                OBJECT(s->canbus), &error_fatal);
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(&s->can), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->can), 0, quard_star_memmap[QUARD_STAR_CAN].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->can), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_CAN_IRQ));
+}
+
+static void quard_star_wdt_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(s), "wdt", &s->wdt, TYPE_IMX2_WDT);
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(&s->wdt), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->wdt), 0, quard_star_memmap[QUARD_STAR_WDT].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(&s->wdt), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_WDT_IRQ));
+    
+}
+
+static void quard_star_pwm_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    object_initialize_child(OBJECT(s), "pwm", &s->pwm, TYPE_SIFIVE_PWM);
+
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(&s->pwm), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(&s->pwm), 0, quard_star_memmap[QUARD_STAR_PWM].base);
+
+    for (int j = 0; j < SIFIVE_PWM_IRQS; j++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(&s->pwm), j,
+                            qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_PWM_IRQ + j));
+    }
+}
+
+static void quard_star_adc_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    s->adc = qdev_new(TYPE_ZYNQ_XADC);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->adc), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->adc), 0, quard_star_memmap[QUARD_STAR_ADC].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(s->adc), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_ADC_IRQ));
+}
+
+static void quard_star_timer_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    s->timer = qdev_new("cadence_ttc");
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->timer), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->timer), 0, quard_star_memmap[QUARD_STAR_TIMER].base);
+    for (int j = 0; j < 3; j++) {
+        sysbus_connect_irq(SYS_BUS_DEVICE(s->timer), j,
+                            qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_TIMER_IRQ + j));
+    }
+}
+
+static void quard_star_eth_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    s->eth = qdev_new(TYPE_CADENCE_GEM);
+    if (nd_table[0].used) {
+        qemu_check_nic_model(&nd_table[0], TYPE_CADENCE_GEM);
+        qdev_set_nic_properties(s->eth, &nd_table[0]);
+    }
+    object_property_set_int(OBJECT(s->eth), "revision", GEM_REVISION, &error_abort);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->eth), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->eth), 0, quard_star_memmap[QUARD_STAR_ETH].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(s->eth), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_ETH_IRQ));
+
+    create_unimplemented_device("riscv.quard_star.eth.gem-mgmt",
+        quard_star_memmap[QUARD_STAR_ETH].base+0x2000, 0x1000);
+}
+
+static void quard_star_lcdc_create(MachineState *machine)
+{
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    s->lcdc = qdev_new("pl111");
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(s->lcdc), &error_fatal);
+    sysbus_mmio_map(SYS_BUS_DEVICE(s->lcdc), 0, quard_star_memmap[QUARD_STAR_LCDC].base);
+    sysbus_connect_irq(SYS_BUS_DEVICE(s->lcdc), 0,
+                        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_LCDC_IRQ));
+}
+
+
+static void quard_star_virtio_mmio_create(MachineState *machine)
+{    
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO0].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO0_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO1].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO1_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO2].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO2_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO3].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO3_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO4].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO4_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO5].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO5_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO6].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO6_IRQ));
+    sysbus_create_simple("virtio-mmio",
+        quard_star_memmap[QUARD_STAR_VIRTIO7].base,
+        qdev_get_gpio_in(DEVICE(s->plic), QUARD_STAR_VIRTIO7_IRQ));
+}
+
+static void quard_star_fw_cfg_create(MachineState *machine)
+{    
+    QuardStarState *s = RISCV_VIRT_MACHINE(machine);
+
+    s->fw_cfg = fw_cfg_init_mem_wide(quard_star_memmap[QUARD_STAR_FW_CFG].base + 8, 
+                                     quard_star_memmap[QUARD_STAR_FW_CFG].base,  8, 
+                                     quard_star_memmap[QUARD_STAR_FW_CFG].base + 16,
+                                     &address_space_memory);
+    fw_cfg_add_i16(s->fw_cfg, FW_CFG_NB_CPUS, (uint16_t)machine->smp.cpus);
+    rom_set_fw(s->fw_cfg);
+}
+
+static void quard_star_machine_init(MachineState *machine)
+{
+    quard_star_cpu_create(machine);
+    quard_star_interrupt_controller_create(machine);
+    quard_star_memory_create(machine);
+    quard_star_flash_create(machine);
+    quard_star_system_control_create(machine);
+    quard_star_rtc_create(machine);
+    quard_star_serial_create(machine);
+    quard_star_i2c_create(machine);
+    quard_star_spi_create(machine);
+    quard_star_usb_create(machine);
+    quard_star_gpio_create(machine);
+    quard_star_dma_create(machine);
+    quard_star_sdio_create(machine);
+    quard_star_i2s_create(machine);
+    quard_star_nand_create(machine);
+    quard_star_can_create(machine);
+    quard_star_wdt_create(machine);
+    quard_star_pwm_create(machine);
+    quard_star_adc_create(machine);
+    quard_star_timer_create(machine);
+    quard_star_eth_create(machine);
+    quard_star_lcdc_create(machine);
+
+    quard_star_virtio_mmio_create(machine);
+    quard_star_fw_cfg_create(machine);
+}
+
+static void quard_star_machine_instance_init(Object *obj)
+{
+}
+
+static Property quard_star_props[] = {
+    DEFINE_PROP_STRING("mask-rom-path", QuardStarState, mask_rom_path),
+    DEFINE_PROP_LINK("canbus", QuardStarState, canbus, TYPE_CAN_BUS, CanBusState *),
+    DEFINE_PROP_END_OF_LIST()
+};
+
+static void quard_star_machine_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->desc = "RISC-V Quard Star board";
+    mc->init = quard_star_machine_init;
+    mc->max_cpus = QUARD_STAR_MANAGEMENT_CPU_COUNT +
+                   QUARD_STAR_COMPUTE_CPU_COUNT;
+    mc->min_cpus = QUARD_STAR_MANAGEMENT_CPU_COUNT +
+                   QUARD_STAR_COMPUTE_CPU_COUNT;
+    mc->default_cpus = mc->min_cpus;
+    mc->default_cpu_type = TYPE_RISCV_CPU_BASE;
+    mc->pci_allow_0_address = true;
+    mc->possible_cpu_arch_ids = riscv_numa_possible_cpu_arch_ids;
+    mc->cpu_index_to_instance_props = riscv_numa_cpu_index_to_props;
+    mc->get_default_cpu_node_id = riscv_numa_get_default_cpu_node_id;
+    mc->numa_mem_supported = true;
+
+    device_class_set_props(DEVICE_CLASS(oc), quard_star_props);
+}
+
+static const TypeInfo quard_star_machine_typeinfo = {
+    .name       = MACHINE_TYPE_NAME("quard-star"),
+    .parent     = TYPE_MACHINE,
+    .class_init = quard_star_machine_class_init,
+    .instance_init = quard_star_machine_instance_init,
+    .instance_size = sizeof(QuardStarState),
+};
+
+static void quard_star_machine_init_register_types(void)
+{
+    type_register_static(&quard_star_machine_typeinfo);
+}
+
+type_init(quard_star_machine_init_register_types)
+
diff --color -Naru ./include/hw/misc/quard_star_syscon.h ./include/hw/misc/quard_star_syscon.h
--- ./include/hw/misc/quard_star_syscon.h	1970-01-01 07:30:00.000000000 +0730
+++ ./include/hw/misc/quard_star_syscon.h	2022-07-21 16:17:15.281117610 +0800
@@ -0,0 +1,43 @@
+/*
+ * QEMU RISC-V Quard Star Board system control
+ *
+ * Copyright (c) 2021 qiao qiming
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HW_QUARD_STAR_SYSCON_H
+#define HW_QUARD_STAR_SYSCON_H
+
+#include "hw/sysbus.h"
+#include "qom/object.h"
+
+#define TYPE_QUARD_STAR_SYSCON "quard-star-syscon"
+
+typedef struct QuardStarSysconState QuardStarSysconState;
+DECLARE_INSTANCE_CHECKER(QuardStarSysconState, QUARD_STAR_SYSCON,
+                         TYPE_QUARD_STAR_SYSCON)
+
+struct QuardStarSysconState {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    MemoryRegion mmio;
+    char *boot_cfg;
+    bool update_cfg;
+};
+
+DeviceState *quard_star_syscon_create(hwaddr addr);
+
+#endif
diff --color -Naru ./include/hw/riscv/quard_star.h ./include/hw/riscv/quard_star.h
--- ./include/hw/riscv/quard_star.h	1970-01-01 07:30:00.000000000 +0730
+++ ./include/hw/riscv/quard_star.h	2022-07-21 16:17:44.337658951 +0800
@@ -0,0 +1,171 @@
+/*
+ * QEMU RISC-V Quard Star Board
+ *
+ * Copyright (c) 2021 qiao qiming
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HW_RISCV_QUARD_STAR__H
+#define HW_RISCV_QUARD_STAR__H
+
+#include "hw/cpu/cluster.h"
+#include "hw/riscv/riscv_hart.h"
+#include "hw/sysbus.h"
+#include "hw/block/flash.h"
+#include "qom/object.h"
+#include "hw/register.h"
+#include "hw/i2c/i2c.h"
+#include "hw/i2c/imx_i2c.h"
+#include "hw/ssi/ssi.h"
+#include "hw/ssi/sifive_spi.h"
+#include "hw/usb/hcd-dwc3.h"
+#include "hw/gpio/sifive_gpio.h"
+#include "hw/dma/sifive_pdma.h"
+#include "hw/sd/cadence_sdhci.h"
+#include "net/can_emu.h"
+#include "hw/net/xlnx-zynqmp-can.h"
+#include "hw/watchdog/wdt_imx2.h"
+#include "hw/timer/sifive_pwm.h"
+#include "hw/adc/zynq-xadc.h"
+#include "hw/net/cadence_gem.h"
+
+#define QUARD_STAR_MANAGEMENT_CPU_COUNT    1
+#define QUARD_STAR_COMPUTE_CPU_COUNT       7
+
+#define TYPE_RISCV_QUARD_STAR_MACHINE MACHINE_TYPE_NAME("quard-star")
+typedef struct QuardStarState QuardStarState;
+DECLARE_INSTANCE_CHECKER(QuardStarState, RISCV_VIRT_MACHINE,
+                         TYPE_RISCV_QUARD_STAR_MACHINE)
+
+struct QuardStarState {
+    /*< private >*/
+    MachineState parent;
+
+    /*< public >*/
+    CPUClusterState r_cluster;
+    CPUClusterState c_cluster;
+    RISCVHartArrayState r_cpus;
+    RISCVHartArrayState c_cpus;
+    DeviceState *plic;
+    PFlashCFI01 *flash;
+    IMXI2CState i2c[3];
+    SiFiveSPIState spi[2];
+    FWCfgState *fw_cfg;
+    USBDWC3 usb;
+    SIFIVEGPIOState gpio;
+    SiFivePDMAState dma;
+    CadenceSDHCIState sdhost;
+    DeviceState *i2s;
+    DeviceState *nand;
+    XlnxZynqMPCANState can;
+    IMX2WdtState   wdt;
+    SiFivePwmState pwm;
+    DeviceState *adc;
+    DeviceState *timer;
+    DeviceState *eth;
+    DeviceState *lcdc;
+
+    I2CSlave *at24c_dev;
+    I2CSlave *wm8750_dev;
+
+    CanBusState *canbus;
+    char *mask_rom_path;
+};
+
+enum {
+    QUARD_STAR_MROM,
+    QUARD_STAR_SRAM,
+    QUARD_STAR_CLINT,
+    QUARD_STAR_PLIC,
+    QUARD_STAR_UART0,
+    QUARD_STAR_UART1,
+    QUARD_STAR_UART2,
+    QUARD_STAR_RTC,
+    QUARD_STAR_I2C0,
+    QUARD_STAR_I2C1,
+    QUARD_STAR_I2C2,
+    QUARD_STAR_SPI0,
+    QUARD_STAR_SPI1,
+    QUARD_STAR_GPIO,
+    QUARD_STAR_SDIO,
+    QUARD_STAR_I2S,
+    QUARD_STAR_NAND,
+    QUARD_STAR_CAN,
+    QUARD_STAR_WDT,
+    QUARD_STAR_PWM,
+    QUARD_STAR_ADC,
+    QUARD_STAR_TIMER,
+    QUARD_STAR_ETH,
+    QUARD_STAR_LCDC,
+    QUARD_STAR_SYSCTL,
+    QUARD_STAR_VIRTIO0,
+    QUARD_STAR_VIRTIO1,
+    QUARD_STAR_VIRTIO2,
+    QUARD_STAR_VIRTIO3,
+    QUARD_STAR_VIRTIO4,
+    QUARD_STAR_VIRTIO5,
+    QUARD_STAR_VIRTIO6,
+    QUARD_STAR_VIRTIO7,
+    QUARD_STAR_FW_CFG,
+    QUARD_STAR_USB,
+    QUARD_STAR_DMA,
+    QUARD_STAR_FLASH,
+    QUARD_STAR_DRAM,
+};
+
+enum {
+    QUARD_STAR_VIRTIO0_IRQ = 1,
+    QUARD_STAR_VIRTIO1_IRQ = 2,
+    QUARD_STAR_VIRTIO2_IRQ = 3,
+    QUARD_STAR_VIRTIO3_IRQ = 4,
+    QUARD_STAR_VIRTIO4_IRQ = 5,
+    QUARD_STAR_VIRTIO5_IRQ = 6,
+    QUARD_STAR_VIRTIO6_IRQ = 7,
+    QUARD_STAR_VIRTIO7_IRQ = 8,
+
+    QUARD_STAR_UART0_IRQ   = 10,
+    QUARD_STAR_UART1_IRQ   = 11,
+    QUARD_STAR_UART2_IRQ   = 12,
+    QUARD_STAR_RTC_IRQ     = 13,
+    QUARD_STAR_I2C0_IRQ    = 14,
+    QUARD_STAR_I2C1_IRQ    = 15,
+    QUARD_STAR_I2C2_IRQ    = 16,
+    QUARD_STAR_SPI0_IRQ    = 17,
+    QUARD_STAR_SPI1_IRQ    = 18,
+    QUARD_STAR_USB_IRQ     = 19,
+    QUARD_STAR_SDIO_IRQ    = 20,
+    QUARD_STAR_I2S_IRQ     = 21,
+    QUARD_STAR_NAND_IRQ    = 22,
+    QUARD_STAR_CAN_IRQ     = 23,
+    QUARD_STAR_ADC_IRQ     = 24,
+    QUARD_STAR_ETH_IRQ     = 25,
+    QUARD_STAR_LCDC_IRQ    = 26,
+    QUARD_STAR_WDT_IRQ     = 27,
+    
+    QUARD_STAR_TIMER_IRQ   = 29, /* 29-31 */
+    QUARD_STAR_PWM_IRQ     = 32, /* 32-35 */
+    QUARD_STAR_GPIO_IRQ    = 36, /* 36-51 */
+    QUARD_STAR_DMA_IRQ     = 52, /* 52-59 */
+};
+
+#define QUARD_STAR_PLIC_NUM_SOURCES    127
+#define QUARD_STAR_PLIC_NUM_PRIORITIES 7
+#define QUARD_STAR_PLIC_PRIORITY_BASE  0x04
+#define QUARD_STAR_PLIC_PENDING_BASE   0x1000
+#define QUARD_STAR_PLIC_ENABLE_BASE    0x2000
+#define QUARD_STAR_PLIC_ENABLE_STRIDE  0x80
+#define QUARD_STAR_PLIC_CONTEXT_BASE   0x200000
+#define QUARD_STAR_PLIC_CONTEXT_STRIDE 0x1000
+
+#endif
diff --color -Naru ./ui/gtk.c ./ui/gtk.c
--- ./ui/gtk.c	2022-04-23 02:42:15.000000000 +0800
+++ ./ui/gtk.c	2022-07-21 16:18:15.478242389 +0800
@@ -544,7 +544,12 @@
     }
 
     if (resized) {
-        gd_update_windowsize(vc);
+        if(vc->s->full_screen){
+            gtk_menu_item_activate(GTK_MENU_ITEM(vc->s->full_screen_item));
+            gtk_menu_item_activate(GTK_MENU_ITEM(vc->s->full_screen_item));
+        } else {
+            gd_update_windowsize(vc);
+        }
     } else {
         gd_update_full_redraw(vc);
     }
